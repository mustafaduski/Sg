<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mind-Blowing 3D Cinematic Intro</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial Black', sans-serif;
            background-color: black;
        }
        #info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: rgba(255,215,0,0.5);
            font-size: 12px;
            letter-spacing: 2px;
            z-index: 100;
            pointer-events: none;
            mix-blend-mode: exclusion;
        }
        /* Fallback for older browsers */
        .no-blend {
            color: gold;
        }
    </style>
</head>
<body>
    <div id="info">TOUCH THE GOLD â€¢ WARP SPEED</div>

    <!-- Import Three.js core and required add-ons from CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.FogExp2(0x050510, 0.0015); // subtle depth

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 18);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // limit for mobile performance
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // --- POST PROCESSING (Bloom for cinematic glow) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- LIGHTS (Cinematic rim and fill) ---
        // Ambient base
        const ambient = new THREE.AmbientLight(0x404060);
        scene.add(ambient);

        // Key light (warm)
        const keyLight = new THREE.PointLight(0xffaa33, 1, 30);
        keyLight.position.set(5, 5, 5);
        scene.add(keyLight);

        // Rim light (cool backlight)
        const rimLight = new THREE.PointLight(0x4466ff, 1.5, 30);
        rimLight.position.set(-5, 0, -10);
        scene.add(rimLight);

        // Fill light for gold
        const fillLight = new THREE.PointLight(0xffdd99, 0.8, 20);
        fillLight.position.set(2, 3, 5);
        scene.add(fillLight);

        // Additional moving light for liquid effect
        const movingLight = new THREE.PointLight(0xffaa00, 1, 20);
        scene.add(movingLight);

        // --- CENTRAL FLOATING LIQUID GOLD ORB ---
        const orbGroup = new THREE.Group();
        
        // Main gold sphere with physical material for metallic look
        const goldMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffaa22,
            emissive: 0x442200,
            metalness: 0.95,
            roughness: 0.25,
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
            reflectivity: 1,
            emissiveIntensity: 0.8
        });
        
        const orbGeo = new THREE.SphereGeometry(1.2, 64, 64);
        const orbMesh = new THREE.Mesh(orbGeo, goldMaterial);
        orbGroup.add(orbMesh);

        // Inner glow sphere (for bloom boost)
        const innerGlowGeo = new THREE.SphereGeometry(1.0, 32, 32);
        const innerGlowMat = new THREE.MeshBasicMaterial({
            color: 0xffaa33,
            transparent: true,
            opacity: 0.15,
            blending: THREE.AdditiveBlending
        });
        const innerGlow = new THREE.Mesh(innerGlowGeo, innerGlowMat);
        orbGroup.add(innerGlow);

        // Tiny orbiting particles around the orb (liquid bubbles)
        const bubbleParticles = new THREE.BufferGeometry();
        const bubbleCount = 80;
        const bubblePositions = new Float32Array(bubbleCount * 3);
        for (let i = 0; i < bubbleCount; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            const r = 1.8 + Math.random() * 0.5;
            bubblePositions[i*3] = Math.sin(phi) * Math.cos(theta) * r;
            bubblePositions[i*3+1] = Math.sin(phi) * Math.sin(theta) * r;
            bubblePositions[i*3+2] = Math.cos(phi) * r;
        }
        bubbleParticles.setAttribute('position', new THREE.BufferAttribute(bubblePositions, 3));
        const bubbleMat = new THREE.PointsMaterial({
            color: 0xffaa33,
            size: 0.05,
            transparent: true,
            blending: THREE.AdditiveBlending
        });
        const bubbles = new THREE.Points(bubbleParticles, bubbleMat);
        orbGroup.add(bubbles);

        scene.add(orbGroup);

        // --- PARTICLE SYSTEM (Stars / Warp speed) ---
        const particleCount = 2500;
        const particles = new THREE.BufferGeometry();
        const posArray = new Float32Array(particleCount * 3);
        const speedArray = new Float32Array(particleCount); // for z velocity

        for (let i = 0; i < particleCount; i++) {
            // Spread in a cylinder shape
            const radius = 15 + Math.random() * 20; // wide area
            const angle = Math.random() * Math.PI * 2;
            const x = Math.cos(angle) * radius * (0.5 + Math.random() * 0.5);
            const y = (Math.random() - 0.5) * 10;
            const z = -50 + Math.random() * 80; // spread in depth
            
            posArray[i*3] = x;
            posArray[i*3+1] = y;
            posArray[i*3+2] = z;
            
            speedArray[i] = 0.02 + Math.random() * 0.06; // speed factor
        }
        
        particles.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        particles.setAttribute('speed', new THREE.BufferAttribute(speedArray, 1));
        
        // Create star texture
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 32;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.arc(16, 16, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-atop';
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.arc(16, 16, 4, 0, Math.PI * 2);
        ctx.fill();
        
        const starTexture = new THREE.CanvasTexture(canvas);
        
        const particleMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.25,
            map: starTexture,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        
        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);

        // Background galaxy spiral (static but rotating)
        const galaxyGeo = new THREE.BufferGeometry();
        const galaxyCount = 800;
        const galaxyPos = new Float32Array(galaxyCount * 3);
        for (let i = 0; i < galaxyCount; i++) {
            const r = 20 + Math.random() * 40;
            const angle = (i % 2 === 0 ? 1 : -1) * r * 0.3 + Math.random() * 0.5;
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;
            const y = (Math.random() - 0.5) * 5;
            galaxyPos[i*3] = x;
            galaxyPos[i*3+1] = y;
            galaxyPos[i*3+2] = z;
        }
        galaxyGeo.setAttribute('position', new THREE.BufferAttribute(galaxyPos, 3));
        const galaxyMat = new THREE.PointsMaterial({ color: 0x88aaff, size: 0.4, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.6 });
        const galaxyPoints = new THREE.Points(galaxyGeo, galaxyMat);
        scene.add(galaxyPoints);

        // --- 3D TEXT WITH MIRROR REFLECTION ---
        const fontLoader = new FontLoader();
        // Use Helvetiker from Three.js examples (external but widely available)
        fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
            const textGeo = new TextGeometry('INFINITY', {
                font: font,
                size: 2.5,
                height: 0.4,
                curveSegments: 6,
                bevelEnabled: true,
                bevelThickness: 0.05,
                bevelSize: 0.03,
                bevelOffset: 0,
                bevelSegments: 4
            });
            
            // Center the text
            textGeo.computeBoundingBox();
            const box = textGeo.boundingBox;
            const centerX = (box.max.x + box.min.x) / 2;
            const centerY = (box.max.y + box.min.y) / 2;
            const centerZ = (box.max.z + box.min.z) / 2;
            
            // Main text material with blending to look part of nebula
            const textMaterial = new THREE.MeshStandardMaterial({
                color: 0xffdd99,
                emissive: 0x442200,
                roughness: 0.3,
                metalness: 0.7,
                emissiveIntensity: 1.2,
                transparent: true,
                blending: THREE.CustomBlending,
                blendSrc: THREE.SrcAlphaFactor,
                blendDst: THREE.OneFactor,
                blendEquation: THREE.AddEquation
            });
            
            const textMesh = new THREE.Mesh(textGeo, textMaterial);
            textMesh.position.set(-centerX, 3.5, -5); // place in front but slightly back
            scene.add(textMesh);

            // Reflection (mirror) - duplicate with inverted Y scale and gradient opacity
            const reflectMat = new THREE.MeshStandardMaterial({
                color: 0xffdd99,
                emissive: 0x221100,
                roughness: 0.5,
                metalness: 0.3,
                transparent: true,
                opacity: 0.25,
                blending: THREE.AdditiveBlending
            });
            
            const reflectMesh = new THREE.Mesh(textGeo, reflectMat);
            reflectMesh.position.copy(textMesh.position);
            reflectMesh.position.y -= 1.8; // adjust for reflection offset
            reflectMesh.scale.set(1, -1, 1); // flip vertically
            reflectMesh.position.y -= 0.2; // fine-tune
            scene.add(reflectMesh);

            // Add a subtle glow plane under text
            const glowPlaneGeo = new THREE.PlaneGeometry(12, 3);
            const glowPlaneMat = new THREE.MeshBasicMaterial({
                color: 0xaa88ff,
                transparent: true,
                opacity: 0.1,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });
            const glowPlane = new THREE.Mesh(glowPlaneGeo, glowPlaneMat);
            glowPlane.position.set(textMesh.position.x, textMesh.position.y - 1.2, textMesh.position.z + 0.5);
            glowPlane.rotation.x = Math.PI / 2;
            scene.add(glowPlane);
        });

        // --- TOUCH INTERACTION (Orb reacts) ---
        let targetOrbRotationX = 0;
        let targetOrbRotationY = 0;
        let currentOrbRotationX = 0;
        let currentOrbRotationY = 0;

        window.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const x = (touch.clientX / window.innerWidth) * 2 - 1;
            const y = -(touch.clientY / window.innerHeight) * 2 + 1;
            
            targetOrbRotationY = x * Math.PI * 0.5;
            targetOrbRotationX = y * Math.PI * 0.3;
            
            // Also move the moving light
            movingLight.position.set(x * 5, y * 3 + 2, 5);
        }, { passive: false });

        window.addEventListener('touchstart', (e) => {
            // Slight pulse on touch
            orbGroup.scale.set(1.1, 1.1, 1.1);
            setTimeout(() => {
                orbGroup.scale.set(1, 1, 1);
            }, 200);
        });

        // --- CAMERA SHAKE on load ---
        let shakeTime = 1.0; // seconds
        const originalCamPos = camera.position.clone();

        // --- ANIMATION LOOP ---
        let clock = new THREE.Clock();

        function animate() {
            const delta = clock.getDelta();
            const elapsedTime = performance.now() / 1000;

            // Camera shake (easing out)
            if (shakeTime > 0) {
                shakeTime -= delta * 0.5;
                const intensity = shakeTime * 0.3;
                camera.position.x = originalCamPos.x + Math.sin(elapsedTime * 50) * intensity;
                camera.position.y = originalCamPos.y + Math.cos(elapsedTime * 40) * intensity;
                camera.position.z = originalCamPos.z + Math.sin(elapsedTime * 30) * intensity;
                camera.lookAt(0, 1, 0);
            } else {
                // Smooth return
                camera.position.lerp(originalCamPos, 0.05);
                camera.lookAt(0, 1, 0);
            }

            // Orb floating animation (organic easing)
            orbGroup.position.y = Math.sin(elapsedTime * 1.5) * 0.3;
            orbGroup.rotation.z = Math.sin(elapsedTime * 0.7) * 0.1;
            
            // Smooth rotation based on touch
            currentOrbRotationX += (targetOrbRotationX - currentOrbRotationX) * 0.08;
            currentOrbRotationY += (targetOrbRotationY - currentOrbRotationY) * 0.08;
            orbGroup.rotation.x = currentOrbRotationX;
            orbGroup.rotation.y = currentOrbRotationY;

            // Rotate bubbles around orb
            bubbles.rotation.y += 0.005;
            bubbles.rotation.x += 0.002;

            // Moving light around orb for liquid shimmer
            movingLight.position.x = Math.sin(elapsedTime * 2) * 4;
            movingLight.position.y = Math.cos(elapsedTime * 1.3) * 3 + 1;
            movingLight.position.z = Math.sin(elapsedTime * 1.8) * 4;

            // Warp speed particles: move towards camera (positive Z) and reset
            const positions = particleSystem.geometry.attributes.position.array;
            const speeds = particleSystem.geometry.attributes.speed.array;
            for (let i = 0; i < particleCount; i++) {
                // Move forward
                positions[i*3+2] += speeds[i] * 0.5; // speed adjusted
                
                // Reset if past camera
                if (positions[i*3+2] > 30) {
                    positions[i*3] = (Math.random() - 0.5) * 40;
                    positions[i*3+1] = (Math.random() - 0.5) * 20;
                    positions[i*3+2] = -80 + Math.random() * -20;
                }
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;

            // Rotate background galaxy slowly
            galaxyPoints.rotation.y += 0.0002;
            galaxyPoints.rotation.x += 0.0001;

            // Render via composer for bloom
            composer.render();

            requestAnimationFrame(animate);
        }

        animate();

        // --- RESIZE HANDLER ---
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // Disable context menu for cleaner interaction
        window.addEventListener('contextmenu', e => e.preventDefault());

        // Additional small stars for depth (static)
        const distantStarsGeo = new THREE.BufferGeometry();
        const distantCount = 800;
        const distantPos = new Float32Array(distantCount * 3);
        for (let i = 0; i < distantCount; i++) {
            distantPos[i*3] = (Math.random() - 0.5) * 200;
            distantPos[i*3+1] = (Math.random() - 0.5) * 200;
            distantPos[i*3+2] = (Math.random() - 0.5) * 200 - 100;
        }
        distantStarsGeo.setAttribute('position', new THREE.BufferAttribute(distantPos, 3));
        const distantStarsMat = new THREE.PointsMaterial({ color: 0x88aadd, size: 0.15, blending: THREE.AdditiveBlending });
        const distantStars = new THREE.Points(distantStarsGeo, distantStarsMat);
        scene.add(distantStars);

        console.log('Mind-Blowing Intro Loaded');
    </script>
</body>
</html>
